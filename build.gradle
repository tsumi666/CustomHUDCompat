plugins {
	id "fabric-loom" version "1.4-SNAPSHOT"
	id "maven-publish"
}

version = project.mod_version
group = project.maven_group

base {
	archivesName = project.archives_base_name
}

repositories {
	// Add repositories to retrieve artifacts from in here.
	// You should only use this when depending on other mods because
	// Loom adds the essential maven repositories to download Minecraft and libraries from automatically.
	// See https://docs.gradle.org/current/userguide/declaring_repositories.html
	// for more information about repositories.
	maven {
		url = "https://api.modrinth.com/maven"
	}
	maven {
		url = "https://cursemaven.com"
	}
}

loom {
	splitEnvironmentSourceSets()

	mods {
		"modid" {
			sourceSet sourceSets.main
			sourceSet sourceSets.client
		}
	}
	runs {
		remove server
	}
}

configurations {
	// Shared between Litematica and Tweakeroo
	sharedMalilib.extendsFrom modImplementation

	// Individual mod configurations
	tweakerooCompat.extendsFrom sharedMalilib
	litematicaCompat.extendsFrom sharedMalilib
}

dependencies {
	// To change the versions see the gradle.properties file
	minecraft "com.mojang:minecraft:${project.minecraft_version}"
	mappings "net.fabricmc:yarn:${project.yarn_mappings}:v2"

	// Dependencies common to all
	modImplementation "net.fabricmc:fabric-loader:${project.loader_version}"
	modImplementation "net.fabricmc.fabric-api:fabric-api:${project.fabric_version}+${project.minecraft_version}"
	modImplementation "maven.modrinth:customhud:${project.customhud_version}+${project.minecraft_version}"

	// Dependencies common to Litematica and Tweakeroo
	sharedMalilib "curse.maven:malilib-303119:${project.malilib_version}"
	// modImplementation "curse.maven:malilib-303119:${project.malilib_version}"

	// Compat-specific dependencies
	tweakerooCompat "curse.maven:tweakeroo-297344:${project.tweakeroo_version}"
	litematicaCompat "curse.maven:litematica-308892:${project.litematica_version}"
	// modImplementation "curse.maven:tweakeroo-297344:${project.tweakeroo_version}"
	// modImplementation "curse.maven:litematica-308892:${project.litematica_version}"
}

def fabricModInfoJson(ArrayList<CompatLayer> layers) {
	def modid
	def name
	def description
	def loader

	if (layers.size() > 1) {
		modid = "compat"
		name = "Mod"
		description = "Loads extra variables for CustomHUD from supported mods: ${layers.collect({ layer -> layer.name }).join(", ")}"
		loader = "Loader"
	} else {
		modid = layers[0].modid
		name = layers[0].name
		description = "Loads extra variables for CustomHUD from the ${layers[0].name} mod"
		loader = "${layers[0].dir}.Loader"
	}

	Map info = [
		schemaVersion: 1,
		id: "customhud_${modid}",
		version: "${version}",
		name: "CustomHUD (${name} Compatibility)",
		description: description,
		authors: [
			"Public Domain"
		],
		contact: [
			homepage: "https://github.com/tsumi666/customhudcompat",
			sources: "https://github.com/tsumi666/customhudcompat"
		],
		license: "CC0-1.0",
		icon: "assets/customhud_compat/icon.png",
		environment: "*",
		entrypoints: [
			client: [
				"we.love.casting.spells.CustomHUD.${loader}"
			]
		],
		depends: [
			java: ">=17",
			minecraft: "~${project.minecraft_version}",
			"fabric-api": "*",
			fabricloader: ">=${project.loader_version}",
			"custom_hud": ">=${project.customhud_version}",
		],
		suggests: layers.size > 1 ? layers.collectEntries { layer -> [ "${layer.modid}": "*" ] } : [:]
	]

	if (layers.size() == 1) {
		info.depends += [ "${layers[0].modid}": "*" ]
	}

	return info
}

class CompatLayer {
	String name // fancy name
	String dir  // layer directory
	String[] extra // extra classes to include
	String modid // layer"s modid
}

ext.layers = [
	new CompatLayer(name: "Tweakeroo", dir: "TweakerooCompat", extra: [ "MalilibUtils" ], modid: "tweakeroo"),
	new CompatLayer(name: "Litematica", dir: "LitematicaCompat", extra: [ "MalilibUtils" ], modid: "litematica")
]

ext.layers.each { layer ->
	def configName = layer.dir[0].toLowerCase() + layer.dir[1..-1]
	tasks.create(name: "generate${layer.dir}Json", type: DefaultTask) {
		dependsOn processResources
		def outputJsonFile = file("build/client/resources/fabric-${layer.modid}.mod.json")
		def outputJson = fabricModInfoJson([layer])
		outputs.file outputJsonFile

		doLast {
			outputJsonFile.text = new groovy.json.JsonBuilder(outputJson).toPrettyString()
		}
	}

	tasks.create(name: "${configName}Jar", type: Jar) {
		dependsOn "generate${layer.dir}Json"
		archiveBaseName = "CustomHUD+${layer.dir}"

		if (configurations.findByName(configName)) {
			from configurations."${configName}"
			compileClientJava {
				doFirst {
					sourceSets.client.java.srcDirs += "build/generated/sources/client/java/main/we/love/casting/spells/CustomHUD/${layer.dir}"
					classpath += configurations."${configName}"
				}
			}
		}

		def fabricModJson = "fabric-${layer.modid}.mod.json"
		from ("build/client/resources/") {
			include fabricModJson
			into "/"
			rename { String fileName -> fileName.replace(fabricModJson, "fabric.mod.json") }
		}

		from ("src/client/resources/") {
			include "assets/customhud_compat/icon.png"
		}

		def basePath = "we/love/casting/spells/CustomHUD/"
		def classes = [ "${layer.dir}/Loader", "${layer.dir}/Layer" ] + layer.extra
		from (sourceSets.client.output) {
		    classes.flatten().each { name ->
		        include "${basePath}/${name}.class"
		        include "${basePath}/${name}\$*.class"
		    }
		}
		from("LICENSE")
	}
	build.dependsOn "${configName}Jar"
}

tasks.create(name: "generateLoaders") {
    doLast {
        def packageName = "we.love.casting.spells.CustomHUD"
		def baseDir = "build/generated/sources/client/java/main/${packageName.replace(".", "/")}"
        layers.each { layer ->
            def sourceFile = file("${baseDir}/${layer.dir}/Loader.java")

            mkdir sourceFile.parentFile
            sourceFile.text = """
                package ${packageName}.${layer.dir};

                import net.fabricmc.api.ClientModInitializer;

                public class Loader implements ClientModInitializer {
                    @Override
	                public void onInitializeClient() {
                        Layer.Load();
                    }
                }
            """
        }

        def sourceFile = file("${baseDir}/Main/Loader.java")
        mkdir sourceFile.parentFile


        sourceFile.text = """
			package ${packageName};

			import net.fabricmc.api.ClientModInitializer;
			import net.fabricmc.loader.api.FabricLoader;

			public class Loader implements ClientModInitializer {
				@Override
				public void onInitializeClient() {
			        ${layers.collect { layer ->
			            "if (has(\"${layer.modid}\")) we.love.casting.spells.CustomHUD.${layer.dir}.Layer.Load();"
			        }.join("\n\t")}
				}

				private static boolean has(String modid) {
					return FabricLoader.getInstance().isModLoaded(modid);
				}
			}
        """
    }
}

tasks.register("setupGeneratedSources") {
	dependsOn generateLoaders
    doLast {
        layers.each { layer ->
            sourceSets.client.java.srcDirs += "build/generated/sources/client/java/main/we/love/casting/spells/CustomHUD/${layer.dir}"
        }
		sourceSets.client.java.srcDirs += "build/generated/sources/client/java/main/we/love/casting/spells/CustomHUD/Main"
    }
}

tasks.named("compileClientJava") {
    dependsOn "setupGeneratedSources"
}

tasks.create(name: "generateModInfoJson", type: DefaultTask) {
	doLast {
		def output = file("build/client/resources/fabric.mod.json")
		mkdir output.parentFile
		output.text = new groovy.json.JsonBuilder(fabricModInfoJson(layers)).toPrettyString()
	}
}
processResources.dependsOn generateModInfoJson

tasks.withType(JavaCompile).configureEach {
	it.options.release = 17
}

java {
	// Loom will automatically attach sourcesJar to a RemapSourcesJar task and to the "build" task
	// if it is present.
	// If you remove this line, sources will not be generated.
	// withSourcesJar()

	sourceCompatibility = JavaVersion.VERSION_17
	targetCompatibility = JavaVersion.VERSION_17
}

jar {
	layers.each { layer ->
		exclude "we/love/casting/spells/CustomHUD/${layer.dir}/Loader*"
	}
	from("build/client/resources/fabric.mod.json")
	from("LICENSE")
}

// configure the maven publication
publishing {
	publications {
		mavenJava(MavenPublication) {
			from components.java
		}
	}

	// See https://docs.gradle.org/current/userguide/publishing_maven.html for information on how to set up publishing.
	repositories {
		// Add repositories to publish to here.
		// Notice: This block does NOT have the same function as the block in the top level.
		// The repositories here will be used for publishing your artifact, not for
		// retrieving dependencies.
	}
}
